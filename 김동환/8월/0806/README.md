# 8월 6일

[나무 재테크](https://www.acmicpc.net/problem/16235)  
[아기 상어](https://www.acmicpc.net/problem/16236)  

## 나무 재테크
### 문제 설명
- 봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 어린 나무부터 양분을 먹는다. 만약, 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.
- 여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.
- 가을에는 나무가 번식한다. (이하 생략)
- 겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.

위와 같은 규칙을 적용하여 시뮬레이션하고, K년 뒤의 살아남은 나무 개수를 구하라.

### 해설
- 시뮬레이션
- 자료구조

쉬운 문제인데, 자료구조 선택의 문제로 조금 고생했다. 

- 우선순위 큐
우선순위 큐를 사용하면 매우 쉽게 나이가 어린 나무부터 양분을 먹도록 구현할 수 있다. 그래서 처음 우선순위 큐를 사용하여 코드를 작성하고 제출하니 시간 초과가 발생했다. 문제의 시간 제한이 0.3초였는데, 우선순위 큐는 내부적으로 매번 정렬을 해야하니 시간 복잡도가 높아 그럴 수 있다고 생각했다.  

- 큐
그래서 우선순위 큐 대신 큐를 사용하도록 코드를 수정하였다. 이럴 경우 가을에 나무가 번식할 때, 새로 생기는 나무를 큐에 먼저 집어넣어야 하기에 임시 메모리 공간을 하나 더 사용해야해 조금 더 귀찮아진다. 그러나 시간 복잡도가 우선순위 큐에 비해 작아지기에 적합한 자료구조라고 생각하고 큐를 사용하게 되었다. 그러나 계속 시간 초과가 발생하게 되고... 함수를 봄, 여름, 가을, 겨울 별로 나눈 것이 문제인가 싶어 더 효율적으로 함수를 압축하였지만 시간 초과가 계속 발생하게 되었다.  

- Vector
그래서 구현을 한번 더 바꾸어 현재 첨부된 코드의 방식대로 Vector를 사용하게 되었다. 단, 더 최적화를 위해 `vector<int> trees[y][x]`와 같은 형태를 사용했다. 이러니 시간 초과가 발생하지 않고 통과하게 되었다.  

그런데 큐를 사용해서 Full Search를 하나 Vector를 사용하여 Full Search를 하나 시간 복잡도는 `O(n)`으로 동일하다. 심지어 내 코드에서 각 배열을 순회할 때, 나이가 적은 나무부터 탐색을 해야하기에 정렬을 매번 하도록 해 사실상 Vector를 사용한 코드의 시간 복잡도가 더 커지게 된다. 그런데도 큐가 더 느리게 동작한다는 것이 이상하여 코드를 까보고 테스트를 해보았다.  

```
void push(const value_type& __v) {c.push_back(__v);}
void pop() {c.pop_front();}
```
우선 큐의 push와 pop은 위처럼 구현되어 있는데, 해당 함수의 형태가 덱(deque)의 형태와 동일하여 조사를 해보니... 실제로 cpp의 큐는 덱을 사용하여 구현되어 있다. 덱은 vector의 단점을 해결하기 위해 나온 자료구조인데, 덱은 첫번째 원소를 빼는데 필요한 시간 복잡도가 `O(1)`이기에 큐와 동일한 시간복잡도를 가지게 된다. 실제로 큐가 덱을 사용하는 형태이니 당연히 시간 복잡도가 `O(1)`이어야 할 것이다. 그렇다면 위에서 설명한 것과 동일하게 더 느리게 동작하는 것이 이상하다.  

그래서 조금 더 알아보니 덱은 구현 자체가 Vector보다 무겁다. 그렇기 때문에 시간 복잡도가 동일하더라도 구현 자체가 무겁기에 실제 시간을 더 오래 걸리게 되는 것이다.  

``` text
size : 40000000
list time : 2212.85ms
queue time : 2891.34ms
deque time : 2658.26ms

size : 50000000
list time : 2571.86ms
queue time : 3630.9ms
deque time : 3320.94ms
```
그래서 [테스트 코드](./time_test.cpp)를 작성하여 테스트해보니 Full Search와 함께 데이터를 넣고 빼는 작업을 할 때, 실제로 Vector보다 덱과 큐가 시간이 더 오래 걸리는 것을 알 수 있다. 심지어 큐는 덱을 한번 랩핑하기에 덱보다도 느리다.  

시간 복잡도가 실제 실행 시간을 보장하지 않는다는 것은 알고 있었지만, 문제를 풀 때 이를 고려해야 하는 경우는 별로 없다. 덕분에 오랜만에 재미있게 공부했다.

## 아기 상어
### 문제 설명
아기 상어는 다음과 같은 규칙으로 물고기를 먹으려 한다.
- 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.
- 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.
- 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.
  - 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.
  - 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.

아기 상어는 다음과 같은 규칙이 적용된다.
- 아기 상어의 이동은 1초가 걸리고, 매번 상하좌우로 한칸 움직일 수 있다.
- 아기 상어는 자기보다 큰 물고기가 있는 칸은 지나갈 수 없다.
- 아기 상어는 자기보다 크기가 작은 물고기를 먹을 수 있고, 물고기를 먹는데 걸리는 시간은 없다.
- 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다.
- 아기 상어의 초기 크기는 2이다.

아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 구하라.

### 해설
- BFS

지정된 규칙을 만족하도록 BFS를 수행하면 된다. BFS로 다음 먹을 물고기를 찾고, 그 위치로 이동한 다음 다시 BFS를 수행하면 된다. 이 과정을 반복하다가 먹을 수 있는 물고기가 없다면 종료하면 된다.  

여기서 신경쓸 점은 `거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.` 이 부분인데, 큐 대신 우선순위 큐를 쓰면 조건을 쉽게 만족할 수 있다.
