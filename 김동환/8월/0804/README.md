# 8월 4일

[레이저 통신](https://www.acmicpc.net/problem/6087)  

## 문제 설명
크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.  

'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.  

레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\')을 설치해서 방향을 90도 회전시킬 수 있다.  

아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '*'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.  

``` text
7 . . . . . . .         7 . . . . . . .
6 . . . . . . C         6 . . . . . /-C
5 . . . . . . *         5 . . . . . | *
4 * * * * * . *         4 * * * * * | *
3 . . . . * . .         3 . . . . * | .
2 . . . . * . .         2 . . . . * | .
1 . C . . * . .         1 . C . . * | .
0 . . . . . . .         0 . \-------/ .
  0 1 2 3 4 5 6           0 1 2 3 4 5 6
```

## 해설
- BFS

설치한 거울의 개수를 기준으로 우선순위 큐에 넣어서 탐색하면 된다. 또한 큐에 넣을 때, 좌표 뿐만 아니라 향하고 있는 방향까지 같이 넣어 주어야 한다. 같은 칸이라도 향하고 있는 방향에 따라 방문해야 할지가 갈리기 때문에, `visited` 배열도 4가지 방향에 대해 만들어주었다.  

추가로 `visited` 배열을 단순 boolean으로 설정하지 않고, int 값을 넣어주었다. 이는 큐에 다음 원소를 넣음과 동시에 방문 체크를 해주는데, 만약 아래와 같은 순서로 큐를 순회하는 경우 단순 boolean을 사용할 시 문제가 발생한다.  

1. 사용한 거울이 0개이고 현재 좌표가 (1, 1)이고 오른쪽 방향으로 가는 원소인데, 거울을 사용하여 윗 방향으로 틀어 (2, 1)에 접근함
2. 사용한 거울이 0개이고 현재 좌표가 (1, 1)이고 윗 방향으로 가는 원소이기에 거울을 사용하지 않고 윗 방향으로 (2, 1)에 접근함

1번과 2번 경우 모두 사용한 거울 개수가 0개이기에, 위와 같은 순서로 실행될 수 있다. 이 경우 2번 케이스가 더 최적의 경우이지만, 1번에서 먼저 방문을 했기에(`visited[2][1][윗방향]`) 2번에서는 이미 방문한 것으로 판단되어 큐에 들어가지 않는다.  

그래서 `visited` 배열을 int로 두고, 초기 값을 매우 큰 수로 설정한다. 이후 해당 위치의 값이 자신의 거울 개수보다 클 경우 방문하지 않은 것으로 판단해 탐색하면 된다.