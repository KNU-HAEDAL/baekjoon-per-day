# 8월 3일

[A와 B](https://www.acmicpc.net/problem/12904)  
[A와 B 2](https://www.acmicpc.net/problem/12919)  

## 문제 설명
두 문자열 S와 T가 주어졌을 때, S를 T로 바꿀 수 있는지 알아내는 프로그램을 작성해라.   

문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.  
- 문자열의 뒤에 A를 추가한다.
- `A와 B` : 문자열을 뒤집고 뒤에 B를 추가한다.
- `A와 B 2` : 문자열의 뒤에 B를 추가하고 문자열을 뒤집는다.  

문자열 S, T의 최대 길이는 `A와 B`에서는 `1000`, `A와 B 2`에서는 `50`이다.

## 해설
- Brute Force
- Greedy

두가지 방법이 있다.  

`solve()` 함수는 문자열 `s`에 위 두 가지 연산을 적용해가며, 문자열 `t`가 만들어지는지 체크하는 방법이다. 이때 어떠한 최적화도 하지 않으면, 문자열의 최대 길이가 50이라 연산의 가짓수가 최대 2^50이 되므로 시간 초과가 발생한다. 그래서 매번 탐색마다 `s`가 `t`의 부분 문자열인지를 체크하고, 아니라면 더이상 깊게 들어가지 않고 빠져나온다. 이 방식은 최적화가 추가된 Brute Force라고 할 수 있다.  

이 문제에서는 문자열의 길이가 짧기에 `solve()` 함수의 방식이 문제 없이 동작한다. 하지만 문자열의 길이가 더 길어진다면, 부분 문자열을 찾는 동작 때문에 시간 초과가 발생할 가능성이 있다고 생각된다. 그래서 다른 해결책을 찾아 보았는데, 그것이 `solve2()`에 기재되어 있다. 이 방식은 반대로 문자열 `t`에서 문자를 하나씩 제거하며 문자열 `s`가 만들어지는지 확인하는 방법이다. 부분 문자열을 체크하는 코드가 없어 조금더 시간적인 측면에서 이득이 있다. 실제로 문자열의 최대 길이가 `1000`인 `A와 B`에서는 위 첫번째 방법이 시간 초과가 발생한다. 이 방식은 매번 최선의 선택을 하게 된다. 즉, Greedy 방식이다.  